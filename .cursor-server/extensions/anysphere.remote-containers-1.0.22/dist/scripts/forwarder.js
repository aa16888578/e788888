"use strict";var __awaiter=this&&this.__awaiter||function(e,r,n,o){return new(n||(n=Promise))((function(t,s){function c(e){try{a(o.next(e))}catch(e){s(e)}}function i(e){try{a(o.throw(e))}catch(e){s(e)}}function a(e){var r;e.done?t(e.value):(r=e.value,r instanceof n?r:new n((function(e){e(r)}))).then(c,i)}a((o=o.apply(e,r||[])).next())}))},__generator=this&&this.__generator||function(e,r){var n,o,t,s,c={label:0,sent:function(){if(1&t[0])throw t[1];return t[1]},trys:[],ops:[]};return s={next:i(0),throw:i(1),return:i(2)},"function"==typeof Symbol&&(s[Symbol.iterator]=function(){return this}),s;function i(i){return function(a){return function(i){if(n)throw new TypeError("Generator is already executing.");for(;s&&(s=0,i[0]&&(c=0)),c;)try{if(n=1,o&&(t=2&i[0]?o.return:i[0]?o.throw||((t=o.return)&&t.call(o),0):o.next)&&!(t=t.call(o,i[1])).done)return t;switch(o=0,t&&(i=[2&i[0],t.value]),i[0]){case 0:case 1:t=i;break;case 4:return c.label++,{value:i[1],done:!1};case 5:c.label++,o=i[1],i=[0];continue;case 7:i=c.ops.pop(),c.trys.pop();continue;default:if(!((t=(t=c.trys).length>0&&t[t.length-1])||6!==i[0]&&2!==i[0])){c=0;continue}if(3===i[0]&&(!t||i[1]>t[0]&&i[1]<t[3])){c.label=i[1];break}if(6===i[0]&&c.label<t[1]){c.label=t[1],t=i;break}if(t&&c.label<t[2]){c.label=t[2],c.ops.push(i);break}t[2]&&c.ops.pop(),c.trys.pop();continue}i=r.call(e,c)}catch(e){i=[6,e],o=0}finally{n=t=0}if(5&i[0])throw i[1];return{value:i[0]?i[1]:void 0,done:!0}}([i,a])}}};Object.defineProperty(exports,"__esModule",{value:!0});var child_process_1=require("child_process"),net=require("net"),util_1=require("util"),execFileAsync=(0,util_1.promisify)(child_process_1.execFile);function logInfo(e){console.info("forwarder: ".concat(e))}function logError(e){console.error("forwarder error: ".concat(e))}var Forwarder=function(){function e(){}return e.prototype.monitorContainerK8s=function(e){var r;return __awaiter(this,void 0,void 0,(function(){var n,o,t;return __generator(this,(function(s){switch(s.label){case 0:s.label=1;case 1:return s.trys.push([1,3,,4]),[4,execFileAsync(e.kubectlPath,["get","pod","--namespace",e.namespace,"--context",e.context,"-o","json",e.podname],{windowsHide:!0})];case 2:return n=s.sent().stdout,o=JSON.parse(n),"Running"===(null===(r=null==o?void 0:o.status)||void 0===r?void 0:r.phase)?[3,4]:(logInfo("Pod not alive: ".concat(JSON.stringify(o))),[3,6]);case 3:return t=s.sent(),logError("Error checking pod status: ".concat(t)),[3,6];case 4:return[4,new Promise((function(e){return setTimeout(e,1e3)}))];case 5:return s.sent(),[3,0];case 6:return[2]}}))}))},e.prototype.monitorContainerDocker=function(e){return __awaiter(this,void 0,void 0,(function(){var r,n,o,t;return __generator(this,(function(s){switch(s.label){case 0:r=0,n=Date.now(),o=function(){var o;return __generator(this,(function(t){switch(t.label){case 0:return o=(0,child_process_1.spawn)(e.dockerPath,["exec","-u",e.remoteUser,"-i",e.containerId,"tail","-f","/dev/null"]),[4,new Promise((function(e){o.on("error",(function(r){e()})),o.once("close",(function(){e()})),o.on("exit",(function(){e()}))}))];case 1:return t.sent(),Date.now()-n>3e4&&(r=0,n=Date.now()),++r>3?(logError("Too many retries in 30 seconds, assuming container is actually dead"),[2,{value:void 0}]):[2]}}))},s.label=1;case 1:return[5,o()];case 2:return"object"==typeof(t=s.sent())?[2,t.value]:[3,1];case 3:return[2]}}))}))},e.prototype.monitorContainer=function(e){return __awaiter(this,void 0,void 0,(function(){return __generator(this,(function(r){switch(r.label){case 0:return"docker"!==e.type?[3,2]:[4,this.monitorContainerDocker(e)];case 1:case 3:return r.sent(),[3,5];case 2:return"k8s"!==e.type?[3,4]:[4,this.monitorContainerK8s(e)];case 4:throw new Error("Invalid config type: ".concat(e));case 5:return[2]}}))}))},e.prototype.generateRemoteNodeJsCodePort=function(e){var r=e.port,n=e.hostname;return"const net = require('net');\nconst fs = require('fs');\nprocess.stdin.pause();\n\nprocess.on('uncaughtException', function (err) {\n    console.error('error: ' + (err.stack || err.message) + '\\n');\n    process.exit(1);\n});\n\nprocess.stdin.on('close', function (hadError) {\n        console.error(hadError ? 'Remote stdin close with error' : 'Remote stdin close');\n        process.exit(hadError ? 1 : 0);\n    });\n\nlet didBind = false;\nlet didTryLocalhostIpv4 = false;\nlet didTryLocalhostIpv6 = false;\n\nfunction setupClient(host) {\n    let noExit = false;\n    const client = net.createConnection({ host, port: ".concat(r,"}, () => {\n        console.error('Connection established on ' + host + ':").concat(r,"');\n        if (didBind) {\n            return;\n        }\n        didBind = true;\n        noExit = false;\n        client.pipe(process.stdout);\n        process.stdin.pipe(client);\n    });\n    client.on('close', function (hadError) {\n        if (!noExit) {\n            console.error(hadError ? 'Remote close with error' : 'Remote close');\n            process.exit(hadError ? 1 : 0);\n        }\n    });\n    client.on('error', function (err) {\n        console.error('client error', err && (err.stack || err.message) || String(err));\n        if ('").concat(n,"' === 'localhost' && !didBind) {\n            // try again with an explicit ipv4 host\n            if (!didTryLocalhostIpv4) {\n                console.error('Retrying on 127.0.0.1');\n                didTryLocalhostIpv4 = true;\n                setupClient('127.0.0.1');\n                noExit = true;\n                return;\n            }\n            if (!didTryLocalhostIpv6) {\n                console.error('Retrying on ::1');\n                didTryLocalhostIpv6 = true;\n                setupClient('::1');\n                noExit = true;\n                return;\n            }\n            console.error('Failed to bind to localhost; exhausted retries');\n        }\n        if (!noExit) {\n            process.exit(1);\n        }\n    });\n}\nsetupClient('").concat(n,"');")},e.prototype.generateRemoteNodeJsCodeSocket=function(e){return"const net = require('net');\nconst fs = require('fs');\nlet connectionCount = 0;\nconst connections = {};\nconst server = net.createServer((socket) => {\n    const i = connectionCount;\n    console.error('Connection established', i);\n    connectionCount++;\n    connections[i] = socket;\n    socket.on('data', (data) => {\n        process.stdout.write(JSON.stringify({i, data: data.toString('base64')}) + '\\n');\n    });\n    socket.on('end', () => {\n        console.error('Socket end', i);\n        process.stdout.write(JSON.stringify({i, end: true}) + '\\n');\n    })\n    socket.on('close', () => {\n        console.error('Socket close', i);\n        process.stdout.write(JSON.stringify({i, close: true}) + '\\n');\n        delete connections[i];\n    })\n    socket.on('error', (err) => {\n        console.error('Connection error', i, err);\n        process.stdout.write(JSON.stringify({i, error: String(err)}) + '\\n');\n        delete connections[i];\n    })\n});\n\nserver.on('close', (hadError) => {\n    console.error(hadError ? 'Remote close with error' : 'Remote close');\n    process.exit(hadError ? 1 : 0);\n});\nserver.on('error', (err) => {\n    process.stderr.write(err && (err.stack || err.message) || String(err));\n});\nlet stdinBuffer = '';\nprocess.stdin.on('data', (data) => {\n    stdinBuffer += Buffer.from(data).toString();\n    let lines = stdinBuffer.split('\\n');\n    stdinBuffer = lines.pop(); // Keep the last incomplete line in buffer\n    for (const line of lines) {\n        if (line.trim()) { // Only process non-empty lines\n          const message = JSON.parse(line);\n            const socket = connections[message.i];\n            if (socket) {\n                if (message.data) {\n                    socket.write(Buffer.from(message.data, 'base64'));\n                }\n                else if (message.end) {\n                    console.error('Message end', message.i);\n                    socket.end();\n                }\n                else if (message.close) {\n                    console.error('Message close', message.i);\n                    socket.destroy();\n                }\n                else if (message.error) {\n                    console.error('Message error', message.i, message.error);\n                    socket.destroy(new Error(message.error));\n                } else {\n                    console.error('Unknown message', message);\n                }\n            } else {\n              if (message.close) {\n                  // meh whatever\n                } else {\n                  console.error('Connection not found: ', line);\n        }\n            }\n        }\n    }\n});\n\nprocess.stdin.on('end', () => {\n    console.error('stdin end');\n    process.exit(0);\n})\nserver.listen({ path: '".concat(e.socket,"' });\n\nprocess.stdin.on('error', (err) => {\n    console.error('stdin error', err);\n    process.exit(1);\n})\nprocess.stdin.on('close', (hadError) => {\n    console.error(hadError ? 'Remote stdin close with error' : 'Remote stdin close');\n    process.exit(hadError ? 1 : 0);\n});\nprocess.on('uncaughtException', (err) => {\n    fs.writeSync(process.stderr.fd, 'error: ' + (err.stack || err.message) + '\\n');\n    process.exit(1);\n});")},e.prototype.handleClientPort=function(e){var r=e.socket,n=e.config,o=e.options,t=e.remoteServerNodePath,s=[],c=this.generateRemoteNodeJsCodePort(o),i="".concat(t,' -e "').concat(c,'"');if("docker"===n.type)s.push(n.dockerPath,"exec","-u",n.remoteUser,"-i",n.containerId,"bash","-c",i);else{if("k8s"!==n.type)throw new Error("Invalid config type: ".concat(n));s.push(n.kubectlPath,"exec","--namespace",n.namespace,"--context",n.context,"-i","-c",n.name,n.podname,"--","bash","-c",i)}var a=(0,child_process_1.spawn)(s[0],s.slice(1),{stdio:["pipe","pipe","pipe"]});return logInfo("[handleClient][subprocess=".concat(a.pid,"][spawn] options: ").concat(JSON.stringify(o))),r.pipe(a.stdin),a.stdout.pipe(r),new Promise((function(e,n){r.on("close",(function(){logError("[handleClient][subprocess=".concat(a.pid,"][socket close]")),a.kill(),e()})),r.on("error",(function(e){logError("[handleClient][subprocess=".concat(a.pid,"][socket error]: ").concat(e.message)),a.kill(),n(e)})),a.stderr.on("data",(function(e){logInfo("[handleClient][subprocess=".concat(a.pid,"][stderr]: ").concat(Buffer.from(e).toString()))})),a.on("error",(function(e){logError("[handleClient][subprocess=".concat(a.pid,"][process error]: ").concat(e.message)),r.end(),n(e)})),a.on("close",(function(){logInfo("[handleClient][subprocess=".concat(a.pid,"][process close]")),r.end(),e()})),a.on("exit",(function(o,t){logInfo("[handleClient][subprocess=".concat(a.pid,"][subprocess exited] ").concat(o," and signal ").concat(t)),r.end(),0!==o?n(new Error("handleClient subprocess exited with code ".concat(o," and signal ").concat(t))):e()}))}))},e.prototype.startServer=function(e){var r=e.config,n=e.localPort,o=e.localHostname,t=e.remotePort,s=e.remoteHostname,c=e.remoteServerNodePath,i=e.portSetter;return __awaiter(this,void 0,void 0,(function(){var e,a=this;return __generator(this,(function(l){switch(l.label){case 0:return logInfo("Forwarding (remote) ".concat(s,":").concat(t," to (local) ").concat(o,":").concat(n)),e=net.createServer((function(e){a.handleClientPort({socket:e,config:r,options:{port:t,hostname:s},remoteServerNodePath:c}).catch((function(r){e.end(),logError("startServer error: ".concat(r instanceof Error?r.message:String(r)))}))})),[4,new Promise((function(t,s){e.on("listening",(function(){var n=e.address().port;logInfo("====forwarderPort=".concat(n,"====")),i(n),a.monitorContainer(r).then((function(){e.close(),logInfo("Stopping forwarding for port ".concat(n)),t()})).catch(s)})),e.on("error",(function(e){s(e)})),e.listen(n,o)}))];case 1:return[2,l.sent()]}}))}))},e.prototype.handleClientSocket=function(e){var r=e.localSocket,n=e.config,o=e.options,t=e.remoteServerNodePath,s=[],c=this.generateRemoteNodeJsCodeSocket(o),i="".concat(t,' -e "').concat(c,'"');if("docker"===n.type)s.push(n.dockerPath,"exec","-u",n.remoteUser,"-i",n.containerId,"bash","-c",i);else{if("k8s"!==n.type)throw new Error("Invalid config type: ".concat(n));s.push(n.kubectlPath,"exec","--namespace",n.namespace,"--context",n.context,"-i","-c",n.name,n.podname,"--","bash","-c",i)}var a=(0,child_process_1.spawn)(s[0],s.slice(1),{stdio:["pipe","pipe","pipe"]}),l={},d="",u=function(e){if(!(e.i in l)){var n=net.createConnection(r);l[e.i]=n,n.on("data",(function(r){a.stdin.write(JSON.stringify({i:e.i,data:r.toString("base64")})+"\n")})),n.on("error",(function(r){var n=r instanceof Error?r.message:String(r);logError("handleClient error: ".concat(n)),a.stdin.write(JSON.stringify({i:e.i,error:n})+"\n"),delete l[e.i]})),n.on("end",(function(){a.stdin.write(JSON.stringify({i:e.i,end:!0})+"\n")})),n.on("close",(function(){a.stdin.write(JSON.stringify({i:e.i,close:!0})+"\n"),delete l[e.i]}))}var o=l[e.i];e.data?o.write(Buffer.from(e.data,"base64")):e.end?o.end():e.error?(logError("handleClient error: ".concat(e.error)),o.destroy(new Error(e.error)),delete l[e.i]):e.close?(o.destroy(),delete l[e.i]):logError("handleClient error: unknown message: ".concat(JSON.stringify(e)))};return a.stdout.on("data",(function(e){var r,n=(d+=Buffer.from(e).toString()).split("\n");d=null!==(r=n.pop())&&void 0!==r?r:"";for(var o=0,t=n;o<t.length;o++){var s=t[o];if(s.trim())try{var c=JSON.parse(s);u(c)}catch(e){console.error("handleClient error: ".concat(e instanceof Error?e.message:String(e)))}}})),a.stderr.on("data",(function(e){logInfo("handleClient stderr: ".concat(Buffer.from(e).toString()))})),new Promise((function(e,r){a.on("error",(function(e){logError("handleClient error: ".concat(e.message)),r(e)})),a.on("close",(function(){logInfo("handleClient subprocess closed"),e()})),a.on("exit",(function(n,o){logInfo("handleClient subprocess exited with code ".concat(n," and signal ").concat(o)),0!==n?r(new Error("handleClient subprocess exited with code ".concat(n," and signal ").concat(o))):e()}))}))},e.prototype.startSocketForward=function(e,r,n,o){return __awaiter(this,void 0,void 0,(function(){var t,s;return __generator(this,(function(c){switch(c.label){case 0:t=this.handleClientSocket({localSocket:r,config:e,options:{socket:n},remoteServerNodePath:o}),logInfo("====socketForward=success===="),c.label=1;case 1:return c.trys.push([1,3,,4]),[4,t];case 2:return c.sent(),[3,4];case 3:throw s=c.sent(),logError("socketForward error: ".concat(s instanceof Error?s.message:String(s))),s;case 4:return logInfo("Stopping forwarding for socket ".concat(r," to ").concat(n," ")),[2]}}))}))},e.prototype.forwardSocket=function(e,r,n,o){return __awaiter(this,void 0,void 0,(function(){return __generator(this,(function(t){switch(t.label){case 0:return[4,this.startSocketForward(e,r,n,o)];case 1:return t.sent(),[2]}}))}))},e}();function main(){var e,r;return __awaiter(this,void 0,void 0,(function(){var n,o,t,s,c,i,a,l,d,u,f,p,h,g,m,w,v,k,y,_,S;return __generator(this,(function(b){switch(b.label){case 0:if(n=process.argv.slice(2),"port"!==(s=n[0])&&"socket"!==s&&(logError('Expected first arg to be "port" or "socket"'),process.exit(1)),8===n.length?(logInfo("Forwarder started with args ".concat(n.join(" "))),d=null!==(e=process.env.KUBECTL_PATH)&&void 0!==e?e:"kubectl",o={type:"k8s",kubectlPath:d,context:n[1],namespace:n[2],podname:n[3],name:n[4]},t=n[5],c=6,i=7,a=6,l=7):6===n.length?(u=n[1],t=n[2],f=n[3],p=null!==(r=process.env.DOCKER_PATH)&&void 0!==r?r:"docker",c=4,i=5,a=4,l=5,o={type:"docker",containerId:u,remoteUser:f,dockerPath:p}):(logError('For kubernetes: Expected arguments: "port"|"socket" <context> <namespace> <podname> <containername> <remote_server_node_path> (<local_host> <remote_host> | <local_socket> <remote_socket>)'),logError('For docker: Expected arguments: "port"|"socket" <container_id> <remote_server_node_path> <remoteUser> (<local_host> <remote_host> | <local_socket> <remote_socket>)'),process.exit(1)),process.stdin.on("data",(function(e){e.includes("\0")&&(logInfo("Received null character, exiting"),process.exit(0))})),process.stdin.on("close",(function(){logInfo("stdin closed"),process.exit(1)})),process.stdin.on("error",(function(e){logError("stdin error: ".concat(e)),process.exit(1)})),process.stdin.resume(),"port"!==s)return[3,5];if(h=n[c],g=void 0,m=void 0,h.startsWith("[")){if(-1===(y=h.indexOf("]"))||":"!==h[y+1])throw new Error("Invalid IPv6 host format: ".concat(h));g=h.slice(1,y),m=Number(h.slice(y+2))}else g=h.split(":")[0],m=parseInt(h.split(":")[1]);if((w=n[i]).startsWith("[")){if(-1===(y=w.indexOf("]"))||":"!==w[y+1])throw new Error("Invalid IPv6 host format: ".concat(w));v=w.slice(1,y),k=Number(w.slice(y+2))}else v=w.split(":")[0],k=parseInt(w.split(":")[1]);return"localhost"!==g?[3,2]:[4,(new Forwarder).startServer({config:o,localPort:m,localHostname:"127.0.0.1",remotePort:k,remoteHostname:v,remoteServerNodePath:t,portSetter:function(e){try{(new Forwarder).startServer({config:o,localPort:e,localHostname:"::1",remotePort:k,remoteHostname:v,remoteServerNodePath:t,portSetter:function(){}}).catch((function(r){logError("Error forwarding port for [::1]:".concat(e,": ").concat(r))}))}catch(r){logError("Error starting fallback server for forwarding port for [::1]:".concat(e,": ").concat(r))}}})];case 1:return b.sent(),[3,4];case 2:return[4,(new Forwarder).startServer({config:o,localPort:m,localHostname:g,remotePort:k,remoteHostname:v,remoteServerNodePath:t,portSetter:function(){}})];case 3:b.sent(),b.label=4;case 4:return[3,7];case 5:return"socket"!==s?[3,7]:(_=n[a],S=n[l],[4,(new Forwarder).forwardSocket(o,_,S,t)]);case 6:b.sent(),b.label=7;case 7:return[2]}}))}))}main().then((function(){logInfo("Forwarder exiting"),process.exit(0)})).catch((function(e){logError(String(e)),process.exit(1)}));